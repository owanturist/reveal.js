Привет, меня зовут Антон, я фронтенд разработчик в Inbox-core. Некоторое время назад я профессионально разрабоатывал веб-приложения на Elm. Elm это строго типизированный функциональный язык, компилируемый в JavaScript, в нём использутся только чистые функции и иммутабельные структуры данных, поэтому, он никогда не падает в runtime. В теории.

Когда я впервые узнал об этом, я подумал: "Погоди минуту, как это он не падает? Допустим, все функции чистые, данные иммутабельны, строгая типизация, но это в вакууме. Данные же как то в него должны попадать, верно? HTTP запросы, localStorage - да весь смысл FE приложений это отображение данных и взаимодействие пользователя с ними. А если данные в http ответе отличаются от ожидаемых - бум, runtime exception!".

Звучит разумно, но что если приложение должно ожидать того, что данные могут быть неправильными?

Вот смотри, допустим есть ночной клуб. Чтобы туда попасть нужно пройти через проверку security на входе. Обычно это грозные амбалы, внушающие страх, чтобы ты оставил плохое настроение у входа. А ещё колющие/режущие предметы, огнестрел, алкоголь, еду, запрещёные препараты и всё то что им не понравится. Ты так же должен быть трезв и хорошо выглядеть. Если что-то из этих пунктов не выполняется - у security есть чёткий план как с тобой попрощаться. Таким образом в клубе остаются только веселые, трезвые, хорошо одетые и безвредные люди. В теории.

Или вот ещё: перед тем как устроится на новую работу тебе надо пройти собеседование. Возможно несколько раундов с разными людьми из разных команд. Здесь тебе надо и хорошее резюме отправить, и иметь подходящий опыт, и подходить по mindset'у, и продемонстрировать что ты умеешь хорошо выполнять свою работу, и проходить по всем остальным специфическим требованиям в зависимости от позиции/компании/команды/ректутёра/обстановки в мире/погоды и других важных аспектов. Если что-то из этого не подходит - у hr есть чёткий план как с тобой попращаться. Таким образом в компанию попадают только лучшие специалисты идеально подходящие на свою должность и разделяющие ценности компании. В теории.

И последний пример: многие из вас переезжали из других стран. Не знаю как у вас, но мне пришлось перевести некоторые вещи с родины. И транспорт это наименьшая из проблем - таможня, вот что доставить головной боли. Чтобы вещи смогли въехать в новую страну нужно тщательно задекларировать каждую мелочь. Есть ещё длинный список запрещёных к ввозу товаров и если что-то на таможне пойдёт не так, у военных есть чёткий план как действовать с твоими вещами. Таким образом в страну попадают только разрешёные безопасные товары и личные вещи. В теории.

И я могу вас заверить, если убрать security, процесс собеседования и пограничников клубы не закроются, компании не разорятся и страны не заполонят нелегальные товары. В большистве своём люди не любят нарушать правила, но малая часть готова это делать по разным причинам. Поэтому мы вынуждены создавать дополнительные проверки для всех, чтобы быть уверенными, что исключительные случаи были выявлены и обработаны.

То же правило справедливо и в работе с данными: в большинстве случаев от сервера приходят ожидаемые ответы, но мы должны выявлять и обрабатывать исключения, чтобы наши пользователи были счастливы.

Так это работает в Elm: в точках взаимодействия между Elm-runtime и диким миром JS есть система преобразования данных, которая в то же время, проверяет их на соответствие ожиданиям. Именно поэтому Elm и не падает: каждый http запрос, содержимое localStorage и даже свойства DOM элементов должны быть декодированы из JS в Elm. Без декодеров гарантия отсутствия ошибок в runtime была бы невыполнима. Так почему бы нам не перенести такую систему в JS или даже в TS?

С ней мы могли бы декларативно, при помощи переиспользуемых блоков описывать ожидаемый JSON и преобразовывать в нужные типы данных (экземпляры классов например). Такой API позволил бы сменить неожиданные ошибки на ожидаемые, обработав которые разработчик сможет использовать декодированные данные с полной поддержкой типов для TS.

(Пример с переиспользованием блоков, oneOf для не консистентных данных, chain для кастомных типов, классы с Point)